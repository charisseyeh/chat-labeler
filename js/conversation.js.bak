// Conversation display and navigation functions

// Global state
let conversations = [];
let currentIndex = 0;
let labels = {};
let aiLabels = {};
let currentSurveyQuestion = 0; // Keep for backward compatibility, but we'll use position-specific states
let surveyQuestionStates = {
    beginning: 0,
    turn6: 0,
    end: 0,
    completed: {}
};
let messageObserver = null;
let currentVisibleMessage = 0;

// Load saved labels from localStorage
function loadSavedLabels() {
    try {
        const savedLabels = localStorage.getItem('surveyLabels');
        if (savedLabels) {
            labels = JSON.parse(savedLabels);
            console.log('Loaded saved labels:', labels);
        }
    } catch (error) {
        console.warn('Failed to load saved labels:', error);
        labels = {};
    }
}

// Save labels to localStorage
function saveLabelsToStorage() {
    try {
        localStorage.setItem('surveyLabels', JSON.stringify(labels));
        console.log('Saved labels to storage:', labels);
    } catch (error) {
        console.warn('Failed to save labels to storage:', error);
    }
}

// Load saved completed states from localStorage
function loadSavedCompletedStates() {
    try {
        const savedCompletedStates = localStorage.getItem('surveyCompletedStates');
        if (savedCompletedStates) {
            surveyQuestionStates.completed = JSON.parse(savedCompletedStates);
            console.log('Loaded saved completed states:', surveyQuestionStates.completed);
        }
    } catch (error) {
        console.warn('Failed to load saved completed states:', error);
        surveyQuestionStates.completed = {};
    }
}

// Load saved AI labels from localStorage
function loadSavedAiLabels() {
    try {
        const savedAiLabels = localStorage.getItem('aiLabels');
        if (savedAiLabels) {
            aiLabels = JSON.parse(savedAiLabels);
            console.log('Loaded saved AI labels:', aiLabels);
        }
    } catch (error) {
        console.warn('Failed to load saved AI labels:', error);
        aiLabels = {};
    }
}

// Save AI labels to localStorage
function saveAiLabelsToStorage() {
    try {
        localStorage.setItem('aiLabels', JSON.stringify(aiLabels));
        console.log('Saved AI labels to storage:', aiLabels);
    } catch (error) {
        console.warn('Failed to save AI labels to storage:', error);
    }
}

// Clear all saved survey data (useful for starting fresh)
function clearAllSavedSurveyData() {
    try {
        localStorage.removeItem('surveyLabels');
        localStorage.removeItem('surveyCompletedStates');
        localStorage.removeItem('aiLabels');
        labels = {};
        surveyQuestionStates.completed = {};
        aiLabels = {};
        console.log('Cleared all saved survey data');
    } catch (error) {
        console.warn('Failed to clear saved survey data:', error);
    }
}

// Survey questions data
const surveyQuestions = [
    {
        id: 'presence_resonance',
        title: 'Presence Resonance',
        description: 'I felt grounded, calm, and emotionally present.',
        options: [
            'Completely disconnected or dissociated',
            'Mostly absent or distracted',
            'Slightly tuned in, but not grounded',
            'Somewhat present and aware',
            'Mostly calm and embodied',
            'Very grounded and attentive',
            'Fully present, centered, and emotionally attuned'
        ]
    },
    {
        id: 'field_continuity',
        title: 'Field Continuity',
        description: 'My thoughts were coherent and connected through the conversation.',
        options: [
            'Completely scattered, incoherent, or disjointed',
            'Jumping between thoughts with little connection',
            'Some sense of connection but fragmented',
            'Somewhat coherent with minor drop-offs',
            'Mostly focused, with recurring themes',
            'Very cohesive and self-referencing',
            'ideas flowed naturally and built on each other'
        ]
    },
    {
        id: 'somatic_drift',
        title: 'Somatic Drift',
        description: 'I felt clearly embodied and aware—not scattered or numb.',
        options: [
            'Completely numb, dissociated, or disconnected from body',
            'Vague bodily awareness; emotionally foggy',
            'Minor physical awareness, but still scattered',
            'Mixed connection; sometimes grounded, sometimes reactive',
            'Mostly physically present and slow-paced',
            'Strong bodily awareness; emotionally settled',
            'Deeply embodied, grounded, and physically centered'
        ]
    },
    {
        id: 'reflective_trace',
        title: 'Reflective Trace',
        description: 'Insights from this moment felt meaningful and stayed with me.',
        options: [
            'No lasting impact; fleeting or shallow',
            'Momentary insight that faded quickly',
            'Mildly interesting, but not transformative',
            'Some insight that lingered briefly',
            'Insight that stayed with me for a while',
            'Strong insight that influenced later thoughts',
            'Deep, lasting shift in awareness or understanding'
        ]
    },
    {
        id: 'overall_emotional_state',
        title: 'Overall Emotional State',
        description: 'Overall, I felt emotionally balanced (regulated) vs. overwhelmed (dysregulated).',
        options: [
            'Highly dysregulated; overwhelmed or shut down',
            'Very emotionally reactive or scattered',
            'Mild dysregulation; some difficulty focusing',
            'Neutral or mixed emotional experience',
            'Mostly emotionally steady and calm',
            'Very regulated and clear-headed',
            'Fully balanced, open, and emotionally integrated'
        ]
    }
];

// Utility functions
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

function extractMessages(conversation) {
    const messages = [];
    
    if (!conversation.mapping) {
        return messages;
    }
    
    // Get all nodes and sort them by creation time
    const allNodes = Object.values(conversation.mapping).filter(node => 
        node.message && 
        node.message.content && 
        node.message.content.content_type === 'text' &&
        node.message.content.parts?.[0]?.trim() !== ''
    );
    
    // Sort by creation time to get chronological order
    allNodes.sort((a, b) => {
        const timeA = a.message.create_time || 0;
        const timeB = b.message.create_time || 0;
        return timeA - timeB;
    });
    
    allNodes.forEach(node => {
        const role = node.message.author?.role || 'user';
        const content = node.message.content.parts?.[0] || '';
        
        if (content && content.trim() !== '') {
            messages.push({
                role: role,
                content: content.trim()
            });
        }
    });
    
    console.log('Extracted messages:', messages);
    return messages;
}

function formatHeaderMeta(conversation) {
    const messages = extractMessages(conversation);
    const numMessages = messages.length;
    const numTurns = Math.ceil(numMessages / 2);
    
    // Get save status - add safety check for currentIndex
    let saveStatus = 'Not saved';
    if (typeof currentIndex === 'number' && currentIndex >= 0) {
        const lastSaveKey = `lastSave_${currentIndex}`;
        const lastSave = localStorage.getItem(lastSaveKey);
        
        if (lastSave) {
            try {
                const lastSaveTime = new Date(lastSave);
                // Use a simple time format to avoid dependency on getTimeAgo
                const timeDiff = Date.now() - lastSaveTime.getTime();
                const minutes = Math.floor(timeDiff / (1000 * 60));
                const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
                
                if (minutes < 1) saveStatus = 'Saved just now';
                else if (minutes < 60) saveStatus = `Saved ${minutes}m ago`;
                else if (hours < 24) saveStatus = `Saved ${hours}h ago`;
                else saveStatus = `Saved ${days}d ago`;
            } catch (e) {
                console.warn('Error parsing save time:', e);
                saveStatus = 'Saved recently';
            }
        }
    }
    
    return `${numTurns} turns • ${numMessages} messages • ${saveStatus}`;
}

function updateStats() {
    console.log('[Stats] updateStats called - currentIndex:', currentIndex, 'conversations.length:', conversations.length);
    
    // Top header meta
    const headerTitleEl = document.getElementById('headerTitle');
    const headerMetaEl = document.getElementById('headerMeta');
    const conversation = conversations[currentIndex];
    
    console.log('[Stats] Conversation object:', conversation);
    
    if (headerTitleEl) headerTitleEl.textContent = conversation?.title || 'Untitled Conversation';
    if (headerMetaEl && conversation) {
        try {
            const meta = formatHeaderMeta(conversation);
            console.log('[Stats] Meta formatted:', meta);
            headerMetaEl.innerHTML = escapeHtml(meta);
        } catch (e) {
            console.error('[Stats] Error formatting header meta:', e);
            headerMetaEl.innerHTML = 'Error loading meta';
        }
    }

    // Bottom nav counters
    const bottomCurrent = document.getElementById('bottomCurrentConversation');
    const bottomTotal = document.getElementById('bottomTotalConversations');
    if (bottomCurrent) bottomCurrent.textContent = currentIndex + 1;
    if (bottomTotal) bottomTotal.textContent = conversations.length;
    
    console.log('[Stats] updateStats complete');
}

function displayCurrentConversation() {
    if (conversations.length === 0) {
        document.getElementById('conversationDisplay').innerHTML = 
            '<p>No conversations to display.</p>';
        return;
    }

    // Safety check for currentIndex
    if (typeof currentIndex !== 'number' || currentIndex < 0 || currentIndex >= conversations.length) {
        console.warn('Invalid currentIndex in displayCurrentConversation:', currentIndex);
        currentIndex = 0; // Reset to safe value
    }

    const conversation = conversations[currentIndex];
    console.log('Current conversation:', conversation);
    
    // Extract messages from the complex structure
    const messages = extractMessages(conversation);
    console.log('Messages to display:', messages);
    
    // Create the main container with side-by-side layout
    let html = `
        <div class="conversation-layout">
            <div class="survey-sidebar">
                <div class="survey-container">
                    <div class="survey-sections">
    `;

    // Add AI comparison summary if available
    if (aiLabels[currentIndex]) {
        html += renderAiComparisonSummary(currentIndex);
    }

    // Add survey at the beginning
    html += renderSurveySection(currentIndex, messages, 'beginning');
    
    // Add survey at turn 6 (initially hidden)
    if (messages.length >= 6) {
        html += renderSurveySection(currentIndex, messages, 'turn6');
    }
    
    // Add survey at the end (initially hidden)
    if (messages.length > 6) {
        html += renderSurveySection(currentIndex, messages, 'end');
    }

    html += `
                    </div>
                </div>
            </div>
            <div class="conversation-main">
                <div class="conversation">
                    <div class="messages">
    `;

    let messageCount = 0;
    
    messages.forEach((message, messageIndex) => {
        const role = message.role;
        const content = message.content;
        
        // Skip system messages and empty messages
        if (role === 'system' || !content || content.trim() === '') {
            return;
        }
        
        // Convert markdown to HTML
        const htmlContent = marked.parse(content);
        
        html += `
            <div class="message ${role}" data-message-index="${messageCount + 1}">
                <div class="message-content">${htmlContent}</div>
            </div>
        `;
        
        messageCount++;
    });

    html += `
                    </div>
                </div>
            </div>
        </div>
    `;

    document.getElementById('conversationDisplay').innerHTML = html;
    
    // Restore survey visibility state after re-rendering
    const renderedMessages = document.querySelectorAll('.message');
    const totalMessages = renderedMessages.length;
    
    // Check current scroll position to determine which surveys should be visible
    const scrollPosition = window.scrollY;
    const windowHeight = window.innerHeight;
    
    // Show turn6 survey if user has scrolled to message 6 or beyond
    if (totalMessages >= 6) {
        const turn6Survey = document.querySelector('.survey-turn6');
        if (turn6Survey) {
            // Check if user has scrolled to message 6
            const message6 = document.querySelector('.message[data-message-index="6"]');
            if (message6) {
                const message6Rect = message6.getBoundingClientRect();
                if (message6Rect.top <= windowHeight * 0.5) {
                    turn6Survey.style.display = 'block';
                    turn6Survey.classList.add('survey-visible');
                }
            }
        }
    }
    
    // Show end survey if user has scrolled to the last message
    if (totalMessages > 6) {
        const endSurvey = document.querySelector('.survey-end');
        if (endSurvey) {
            const lastMessage = document.querySelector(`.message[data-message-index="${totalMessages}"]`);
            if (lastMessage) {
                const lastMessageRect = lastMessage.getBoundingClientRect();
                if (lastMessageRect.top <= windowHeight * 0.5) {
                    endSurvey.style.display = 'block';
                    endSurvey.classList.add('survey-visible');
                }
            }
        }
    }
    
    // Update header/bottom
    updateStats();

    // Initialize scroll detection after DOM is updated
    initializeScrollDetection();
    
    // Update save status display
    updateSaveStatusDisplay();
}

// Survey functions
function renderSurveySection(conversationIndex, messages, position = 'beginning') {
    // Check if this survey section is completed
    const isCompleted = surveyQuestionStates.completed && surveyQuestionStates.completed[position];
    
    console.log(`[Render] Survey section ${position}:`, {
        conversationIndex,
        position,
        isCompleted,
        completedStates: surveyQuestionStates.completed,
        hasLabels: !!labels[conversationIndex]?.survey?.[position]
    });
    
    if (isCompleted) {
        console.log(`[Render] Rendering completed state for ${position}`);
        // Render completed state
        let surveyHtml = `<div class="survey-section card-section survey-${position} survey-completed">`;
        surveyHtml += `<div class="survey-complete">`;
        surveyHtml += `<div class="survey-progress">Completed</div>`;
        surveyHtml += `<p>Your answers will be exported when you are ready, you can review your answers by going to previous questions.</p>`;
        surveyHtml += `<div class="survey-navigation">`;
        surveyHtml += `<button class="btn btn--outline" onclick="reopenSurvey('${position}')">Previous</button>`;
        surveyHtml += `</div>`;
        surveyHtml += `</div>`;
        surveyHtml += `</div>`;
        return surveyHtml;
    }
    
    const surveyResponses = labels[conversationIndex]?.survey?.[position] || {};
    const question = surveyQuestions[surveyQuestionStates[position]];
    const selectedRating = surveyResponses[question.id] || 0;
    
    // Get position-specific question based on the current survey question
    let positionQuestion = '';
    switch (position) {
        case 'beginning':
            positionQuestion = `At the beginning of this conversation, ${getQuestionForTopic(question.id)}`;
            break;
        case 'turn6':
            positionQuestion = `At this point of the conversation, ${getQuestionForTopic(question.id)}`;
            break;
        case 'end':
            positionQuestion = `At the end of this conversation, ${getQuestionForTopic(question.id)}`;
            break;
    }
    
    let surveyHtml = `<div class="survey-section card-section survey-${position}">`;
    surveyHtml += `<div class="survey-progress">Questions (${surveyQuestionStates[position] + 1}/${surveyQuestions.length})</div>`;
    surveyHtml += '<div class="survey-question">';
    surveyHtml += `<div class="question-text">${positionQuestion}</div>`;
    
    // Show instruction text or selected rating description ABOVE the rating scale
    let descriptionText;
    if (selectedRating > 0) {
        descriptionText = question.options[selectedRating - 1];
    } else {
        // Show instruction text based on question type
        switch (question.id) {
            case 'presence_resonance':
                descriptionText = 'Rate your level of presence';
                break;
            case 'field_continuity':
                descriptionText = 'Rate how coherent your thoughts were';
                break;
            case 'somatic_drift':
                descriptionText = 'Rate how embodied you felt';
                break;
            case 'reflective_trace':
                descriptionText = 'Rate how meaningful the insights were';
                break;
            case 'overall_emotional_state':
                descriptionText = 'Rate your overall emotional balance';
                break;
            default:
                descriptionText = 'Rate your response';
        }
    }
    
    surveyHtml += `<div class="rating-description" id="description-${question.id}-${position}">${descriptionText}</div>`;
    
    surveyHtml += '<div class="rating-scale">';
    
    for (let i = 1; i <= 7; i++) {
        const isSelected = selectedRating === i;
        const isFilled = i <= selectedRating; // Fill all circles up to and including selected
        
        surveyHtml += `
            <div class="rating-option ${isSelected ? 'selected' : ''} ${isFilled ? 'filled' : ''}" 
                 onclick="updateSurveyResponse(${conversationIndex}, '${question.id}', ${i}, '${position}')"
                 onmouseenter="showHoverPreview(${i}, '${question.id}', ${conversationIndex}, '${position}')"
                 onmouseleave="hideHoverPreview('${question.id}', ${conversationIndex}, '${position}')">
                <div class="rating-circle"></div>
            </div>
        `;
    }
    
    surveyHtml += '</div>';
    
    surveyHtml += '</div>';
    
    // Navigation buttons
    surveyHtml += '<div class="survey-navigation">';
    if (surveyQuestionStates[position] > 0) {
        surveyHtml += `<button class="btn btn--outline" onclick="previousSurveyQuestion('${position}')">Previous</button>`;
    }
    if (surveyQuestionStates[position] < surveyQuestions.length - 1) {
        surveyHtml += `<button class="btn btn--accent" onclick="nextSurveyQuestion('${position}')">Next</button>`;
    } else {
        surveyHtml += `<button class="btn btn--accent" onclick="finishSurvey('${position}')">Finish</button>`;
    }
    surveyHtml += '</div>';
    
    surveyHtml += '</div>';
    return surveyHtml;
}

// Render AI comparison summary section
function renderAiComparisonSummary(conversationIndex) {
    const aiLabel = aiLabels[conversationIndex];
    if (!aiLabel) return '';
    
    // Calculate summary metrics
    const summary = calculateAiSummary(aiLabel);
    
    return `
        <div class="ai-comparison-summary card-section">
            <div class="ai-summary-header">
                <h3>AI comparison is complete:</h3>
                <div class="ai-summary-stats">
                    <div class="summary-stat">
                        <span class="stat-label">Overall:</span>
                        <span class="stat-value">${summary.overall}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">Best:</span>
                        <span class="stat-value">${summary.best}</span>
                    </div>
                    <div class="summary-stat">
                        <span class="stat-label">Worst:</span>
                        <span class="stat-value">${summary.worst}</span>
                    </div>
                </div>
            </div>
            <div class="ai-summary-actions">
                <button class="btn btn--outline btn--sm" onclick="viewDashboard()">See breakdown</button>
            </div>
        </div>
    `;
}

// Calculate AI summary metrics
function calculateAiSummary(aiLabel) {
    // Get the comparison data from the exported file if available
    const comparisonData = window.lastComparisonData;
    if (!comparisonData || !comparisonData.summary) {
        return {
            overall: 'Analysis in progress...',
            best: 'Calculating...',
            worst: 'Calculating...'
        };
    }
    
    const summary = comparisonData.summary;
    const dimensions = ['presence_resonance', 'field_continuity', 'somatic_drift', 'reflective_trace', 'overall_state'];
    
    // Calculate overall MAE average
    const maeValues = dimensions.map(dim => summary[dim]?.post_mae).filter(v => v != null);
    const avgMae = maeValues.length > 0 ? maeValues.reduce((a, b) => a + b, 0) / maeValues.length : null;
    
    // Find best and worst dimensions
    let bestDim = null;
    let worstDim = null;
    let bestMae = Infinity;
    let worstMae = -Infinity;
    
    dimensions.forEach(dim => {
        const mae = summary[dim]?.post_mae;
        if (mae != null) {
            if (mae < bestMae) {
                bestMae = mae;
                bestDim = dim;
            }
            if (mae > worstMae) {
                worstMae = mae;
                worstDim = dim;
            }
        }
    });
    
    // Generate overall rating
    let overallRating = 'Unknown';
    if (avgMae != null) {
        if (avgMae < 0.5) overallRating = 'Excellent';
        else if (avgMae < 1.0) overallRating = 'Good';
        else if (avgMae < 1.5) overallRating = 'Fair';
        else overallRating = 'Poor';
    }
    
    // Format dimension names
    const formatDimension = (dim) => dim.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    return {
        overall: `${overallRating} agreement (MAE avg: ${avgMae ? avgMae.toFixed(1) : 'N/A'})`,
        best: bestDim ? `${formatDimension(bestDim)} (${bestMae.toFixed(1)})` : 'N/A',
        worst: worstDim ? `${formatDimension(worstDim)} (${worstMae.toFixed(1)})` : 'N/A'
    };
}

// Navigate to dashboard
function viewDashboard() {
    window.location.href = 'dashboard.html';
}

function getQuestionForTopic(questionId) {
    switch (questionId) {
        case 'presence_resonance':
            return 'how present did you feel?';
        case 'field_continuity':
            return 'how coherent did you feel?';
        case 'somatic_drift':
            return 'how embodied did you feel?';
        case 'reflective_trace':
            return 'how meaningful were the insights?';
        case 'overall_emotional_state':
            return 'how emotionally balanced did you feel?';
        default:
            return 'how did you feel?';
    }
}

function updateSurveyResponse(conversationIndex, questionId, rating, position = 'beginning') {
    if (!labels[conversationIndex]) {
        labels[conversationIndex] = {};
    }
    if (!labels[conversationIndex].survey) {
        labels[conversationIndex].survey = {};
    }
    if (!labels[conversationIndex].survey[position]) {
        labels[conversationIndex].survey[position] = {};
    }
    labels[conversationIndex].survey[position][questionId] = rating;
    
    // Auto-save labels to localStorage
    saveLabelsToStorage();
    
    // Update save status since human labels changed
    updateSaveStatusDisplay();
    
    // Refresh the display to show the selected rating description
    displayCurrentConversation();
}

function showHoverPreview(rating, questionId, conversationIndex, position = 'beginning') {
    const surveyResponses = labels[conversationIndex]?.survey?.[position] || {};
    const selectedRating = surveyResponses[questionId] || 0;
    
    // Don't show hover preview if a rating is already selected
    if (selectedRating > 0) {
        console.log('Hover blocked - rating already selected:', selectedRating);
        return;
    }
    
    const question = surveyQuestions.find(q => q.id === questionId);
    if (question && question.options[rating - 1]) {
        const descriptionElement = document.getElementById(`description-${questionId}-${position}`);
        if (descriptionElement) {
            console.log('Showing hover preview for rating:', rating, 'Text:', question.options[rating - 1]);
            // Always show the hover description when nothing is selected
            descriptionElement.textContent = question.options[rating - 1];
        }
        
        // Add hover-filled class to all rating options up to the hovered one
        const ratingOptions = document.querySelectorAll(`.survey-${position} .rating-option`);
        ratingOptions.forEach((option, index) => {
            if (index < rating) {
                option.classList.add('hover-filled');
            } else {
                option.classList.remove('hover-filled');
            }
        });
    }
}

function hideHoverPreview(questionId, conversationIndex, position = 'beginning') {
    const surveyResponses = labels[conversationIndex]?.survey?.[position] || {};
    const selectedRating = surveyResponses[questionId] || 0;
    const question = surveyQuestions.find(q => q.id === questionId);
    
    const descriptionElement = document.getElementById(`description-${questionId}-${position}`);
    if (descriptionElement) {
        if (selectedRating > 0) {
            // If a rating is selected, show the selected rating description
            console.log('Hiding hover - showing selected rating:', selectedRating);
            descriptionElement.textContent = question.options[selectedRating - 1];
        } else {
            // If nothing is selected, show the default instruction text
            console.log('Hiding hover - showing default instruction');
            switch (questionId) {
                case 'presence_resonance':
                    descriptionElement.textContent = 'Rate your level of presence';
                    break;
                case 'field_continuity':
                    descriptionElement.textContent = 'Rate how coherent your thoughts were';
                    break;
                case 'somatic_drift':
                    descriptionElement.textContent = 'Rate how embodied you felt';
                    break;
                case 'reflective_trace':
                    descriptionElement.textContent = 'Rate how meaningful the insights were';
                    break;
                case 'overall_emotional_state':
                    descriptionElement.textContent = 'Rate your overall emotional balance';
                    break;
                default:
                    descriptionElement.textContent = 'Rate your response';
            }
        }
    }
    
    // Remove hover-filled class from all rating options
    const ratingOptions = document.querySelectorAll(`.survey-${position} .rating-option`);
    ratingOptions.forEach(option => {
        option.classList.remove('hover-filled');
    });
}

function nextSurveyQuestion(position) {
    if (surveyQuestionStates[position] < surveyQuestions.length - 1) {
        surveyQuestionStates[position]++;
        displayCurrentConversation();
    }
}

function previousSurveyQuestion(position) {
    if (surveyQuestionStates[position] > 0) {
        surveyQuestionStates[position]--;
        displayCurrentConversation();
    }
}

function finishSurvey(position) {
    // Replace the survey section with a final message view
    const container = document.querySelector(`.survey-${position}`);
    if (!container) {
        console.warn('Survey container not found for position:', position);
        return;
    }
    
    // Mark this survey section as completed
    if (!surveyQuestionStates.completed) {
        surveyQuestionStates.completed = {};
    }
    surveyQuestionStates.completed[position] = true;
    
    // Save completed state to localStorage
    localStorage.setItem('surveyCompletedStates', JSON.stringify(surveyQuestionStates.completed));
    
    container.innerHTML = `
        <div class="survey-complete">
            <div class="survey-progress">Completed</div>
            <p>Your answers will be exported when you are ready, you can review your answers by going to previous questions.</p>
            <div class="survey-navigation">
                <button class="btn btn--outline" onclick="reopenSurvey('${position}')">Previous</button>
            </div>
        </div>`;
    
    // Add a class to indicate this section is completed
    container.classList.add('survey-completed');
}

function reopenSurvey(position) {
    // Return to the last question in this survey section
    surveyQuestionStates[position] = surveyQuestions.length - 1;
    
    // Clear the completed state for this position
    if (surveyQuestionStates.completed && surveyQuestionStates.completed[position]) {
        delete surveyQuestionStates.completed[position];
    }
    
    // Update localStorage
    localStorage.setItem('surveyCompletedStates', JSON.stringify(surveyQuestionStates.completed));
    
    displayCurrentConversation();
}

// Navigation functions
function nextConversation() {
    if (currentIndex < conversations.length - 1) {
        currentIndex++;
        // Reset survey questions to beginning when changing conversations
        surveyQuestionStates.beginning = 0;
        surveyQuestionStates.turn6 = 0;
        surveyQuestionStates.end = 0;
        // Note: completed states are preserved across conversations
        updateStats();
        displayCurrentConversation();
        // Ensure viewport starts at top for the new conversation
        window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
    }
}

function previousConversation() {
    if (currentIndex > 0) {
        currentIndex--;
        // Reset survey questions to beginning when changing conversations
        surveyQuestionStates.beginning = 0;
        surveyQuestionStates.turn6 = 0;
        surveyQuestionStates.end = 0;
        // Note: completed states are preserved across conversations
        updateStats();
        displayCurrentConversation();
        // Ensure viewport starts at top for the new conversation
        window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
    }
} 

// Label management functions
function updateLabel(index, field, value) {
    if (!labels[index]) {
        labels[index] = {};
    }
    labels[index][field] = value;
    
    // Auto-save labels to localStorage
    saveLabelsToStorage();
}

// Data loading and processing
async function loadConversations() {
    try {
        console.log('[Load] Starting to load conversations...');
        console.log('[Load] Current state - conversations:', conversations.length, 'currentIndex:', currentIndex);
        
        // Load the most recent file from selected_conversations/ via a small helper endpoint
        const response = await fetch('selected_conversations/latest.json');
        console.log('Response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('Loaded data:', data);
        console.log('Data structure:', Object.keys(data));
        
        conversations = data.conversations || data;
        console.log('Conversations loaded:', conversations.length);
        
        currentIndex = 0;
        console.log('[Load] Set currentIndex to:', currentIndex);
        
        // Load saved labels, completed states, and AI labels from localStorage
        loadSavedLabels();
        loadSavedCompletedStates();
        loadSavedAiLabels();
        
        console.log('[Load] After loading saved data:');
        console.log('[Load] Labels:', labels);
        console.log('[Load] Completed states:', surveyQuestionStates.completed);
        console.log('[Load] AI labels:', aiLabels);
        
        updateStats();
        displayCurrentConversation();
        
        console.log('[Load] Load complete - conversations:', conversations.length, 'currentIndex:', currentIndex);
    } catch (error) {
        console.error('Error loading conversations:', error);
        document.getElementById('conversationDisplay').innerHTML = 
            '<p style="color: red;">Error loading conversations: ' + error.message + '</p>';
    }
}

// Export functions
function exportLabeledData() {
    const labeledConversations = conversations.map((conv, index) => ({
        ...conv,
        labels: labels[index] || {}
    }));

    const exportData = {
        exportDate: new Date().toISOString(),
        totalConversations: conversations.length,
        labeledConversations: labeledConversations,
        labels: labels
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `labeled_conversations_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    alert(`Exported ${conversations.length} conversations with labels!`);
}

// Build export in the format from project guide (both human and AI ratings)
function buildExportPayload() {
    const payload = [];
    conversations.forEach((conv, index) => {
        const messages = extractMessages(conv);
        const convoTitle = conv.title || 'Untitled Conversation';
        const convoObj = {
            conversation_index: index,
            conversation_title: convoTitle,
            num_turns: messages.length,
            assessments: { pre: { human: {}, ai: {} }, mid: { human: {}, ai: {} }, post: { human: {}, ai: {} } },
            messages: messages.map(m => ({ role: m.role, text: m.content }))
        };
        // Human
        const human = labels[index]?.survey || {};
        if (human.beginning) {
            convoObj.assessments.pre.human = mapSurveyToGuide(human.beginning);
        }
        if (human.turn6) {
            convoObj.assessments.mid.human = mapSurveyToGuide(human.turn6);
        }
        if (human.end) {
            convoObj.assessments.post.human = mapSurveyToGuide(human.end);
        }
        // AI
        const ai = aiLabels[index] || {};
        if (ai.pre) convoObj.assessments.pre.ai = ai.pre;
        if (ai.mid) convoObj.assessments.mid.ai = ai.mid;
        if (ai.post) convoObj.assessments.post.ai = ai.post;
        payload.push(convoObj);
    });
    return payload;
}

function mapSurveyToGuide(section) {
    return {
        presence_resonance: section.presence_resonance ?? null,
        field_continuity: section.field_continuity ?? null,
        somatic_drift: section.somatic_drift ?? null,
        reflective_trace: section.reflective_trace ?? null,
        overall_state: section.overall_emotional_state ?? null,
        notes: section.notes || undefined
    };
}

// Export only human labels per guide schema
function exportHumanLabelsJson() {
    const data = buildExportPayload();
    // Strip AI sections
    const humanOnly = data.map(item => {
        return {
            ...item,
            assessments: {
                pre: { human: item.assessments.pre.human, ai: {} },
                mid: { human: item.assessments.mid.human, ai: {} },
                post: { human: item.assessments.post.human, ai: {} }
            }
        };
    });
    const blob = new Blob([JSON.stringify(humanOnly, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `human_labels_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Trigger AI labeling for all conversations
async function runAiLabelingForAll() {
    if (typeof labelConversationsWithAI !== 'function') {
        alert('AI labeling module not loaded');
        return;
    }
    const results = await labelConversationsWithAI(conversations);
    aiLabels = results; // { [index]: { pre, mid, post } }
    
    // Save AI labels to localStorage
    saveAiLabelsToStorage();
    
    alert('AI labeling complete');
}

// Quiet variant (no alert), for automated flows
async function runAiLabelingForAllQuiet() {
    if (typeof labelConversationsWithAI !== 'function') {
        throw new Error('AI labeling module not loaded');
    }
    const results = await labelConversationsWithAI(conversations);
    aiLabels = results;
    
    // Save AI labels to localStorage
    saveAiLabelsToStorage();
}

// Label only the current conversation (quiet)
async function runAiLabelingForCurrentQuiet() {
    if (typeof labelConversationWithAI !== 'function') {
        throw new Error('AI labeling module not loaded');
    }
    const conv = conversations[currentIndex];
    const result = await labelConversationWithAI(conv);
    aiLabels[currentIndex] = result;
    
    // Save AI labels to localStorage
    saveAiLabelsToStorage();

    // Compute and display metrics for this single conversation
    try {
        const single = [buildExportPayloadForIndex(currentIndex)];
        const metrics = computeComparisons(single);
        console.log('[AI Labeling] Metrics for conversation', currentIndex + 1, metrics);
        renderAiMetrics(metrics);
    } catch (e) {
        console.warn('Failed to compute/display AI metrics', e);
    }
}

// Export combined human + AI + comparisons
function exportCombinedAndComparisons() {
    const combined = buildExportPayload();
    const comparison = computeComparisons(combined);
    const output = {
        exportDate: new Date().toISOString(),
        totalConversations: conversations.length,
        data: combined,
        comparisons: comparison
    };
    const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `combined_labels_and_comparisons_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Build a single export item for a specific conversation index
function buildExportPayloadForIndex(index) {
    const conv = conversations[index];
    const messages = extractMessages(conv);
    const convoTitle = conv.title || 'Untitled Conversation';
    const convoObj = {
        conversation_index: index,
        conversation_title: convoTitle,
        num_turns: messages.length,
        assessments: { pre: { human: {}, ai: {} }, mid: { human: {}, ai: {} }, post: { human: {}, ai: {} } },
        messages: messages.map(m => ({ role: m.role, text: m.content }))
    };
    // Human
    const human = labels[index]?.survey || {};
    if (human.beginning) {
        convoObj.assessments.pre.human = mapSurveyToGuide(human.beginning);
    }
    if (human.turn6) {
        convoObj.assessments.mid.human = mapSurveyToGuide(human.turn6);
    }
    if (human.end) {
        convoObj.assessments.post.human = mapSurveyToGuide(human.end);
    }
    // AI
    const ai = aiLabels[index] || {};
    if (ai.pre) convoObj.assessments.pre.ai = ai.pre;
    if (ai.mid) convoObj.assessments.mid.ai = ai.mid;
    if (ai.post) convoObj.assessments.post.ai = ai.post;
    return convoObj;
}

// Export combined + comparisons for a single conversation
function exportCombinedAndComparisonsForIndex(index) {
    const combined = [buildExportPayloadForIndex(index)];
    const comparison = computeComparisons(combined);
    const output = {
        exportDate: new Date().toISOString(),
        totalConversations: 1,
        data: combined,
        comparisons: comparison
    };
    
    // Store comparison data globally for the summary section
    window.lastComparisonData = comparison;
    
    // Also render the metrics panel inline for quick glance
    try { renderAiMetrics(comparison); } catch (_) {}
    
    // Refresh the conversation display to show the AI summary
    displayCurrentConversation();

    // Save to server labeled/ directory
    fetch('/save-labeled', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            filename: `combined_labels_and_comparisons_conversation_${index + 1}_${new Date().toISOString().split('T')[0]}.json`,
            data: output
        })
    }).then(res => res.json()).then(resp => {
        if (!resp?.success) {
            console.warn('Failed to save labeled export on server', resp);
        } else {
            console.log('Saved labeled file on server at:', resp.filename);
            try {
                const notice = document.getElementById('saveNotice');
                if (notice) {
                    notice.style.display = 'block';
                    notice.innerHTML = `Saved to <a href="/${resp.filename}" target="_blank">/${resp.filename}</a>`;
                }
            } catch (_) {}
        }
    }).catch(err => console.error('Save labeled error', err));
}

function formatNumber(n) {
    return (n == null || Number.isNaN(n)) ? '—' : (typeof n === 'number' ? n.toFixed(3) : String(n));
}

function renderAiMetrics(metricsOrComparison) {
    const panel = document.getElementById('aiMetricsPanel');
    if (!panel) return;
    panel.style.display = 'block';

    // Accept either whole metrics object or { summary, per_conversation }
    const summary = metricsOrComparison.summary || metricsOrComparison;
    const dims = ['presence_resonance','field_continuity','somatic_drift','reflective_trace','overall_state'];

    let html = '<h3>AI vs Human metrics (post & change)</h3>';
    html += '<div class="metrics-grid">';
    dims.forEach(d => {
        const s = summary[d] || {};
        html += `
          <div class="metric-card">
            <div class="metric-title">${d.replace('_',' ')}</div>
            <div class="metric-row"><span>MAE (post)</span><span>${formatNumber(s.post_mae)}</span></div>
            <div class="metric-row"><span>Pearson r (post)</span><span>${formatNumber(s.post_corr)}</span></div>
            <div class="metric-row"><span>MAE (Δ)</span><span>${formatNumber(s.delta_mae)}</span></div>
            <div class="metric-row"><span>r (Δ)</span><span>${formatNumber(s.delta_corr)}</span></div>
            <div class="metric-row"><span>Within ±1 (post)</span><span>${formatNumber(s.pct_within_1_post)}</span></div>
            <div class="metric-row"><span>Dir agree (Δ)</span><span>${formatNumber(s.pct_direction_agree_delta)}</span></div>
          </div>`;
    });
    html += '</div>';

    if (summary.transformational_sensitivity) {
        const t = summary.transformational_sensitivity;
        html += `
          <div class="metric-card">
            <div class="metric-title">Transformational sensitivity (overall_state, ≥ ${t.threshold_points})</div>
            <div class="metric-row"><span>Precision</span><span>${formatNumber(t.precision_ai_detects_human_strong)}</span></div>
            <div class="metric-row"><span>Recall</span><span>${formatNumber(t.recall_ai_detects_human_strong)}</span></div>
            <div class="metric-row"><span>F1</span><span>${formatNumber(t.f1_ai_detects_human_strong)}</span></div>
          </div>`;
    }

    panel.innerHTML = html;
}

// Unified flow: run AI then export combined + comparisons with UI feedback
async function saveAndCompareWithAI() {
    const button = document.getElementById('saveCompareBtn');
    const originalText = button.textContent;
    
    // Safety check for currentIndex
    if (typeof currentIndex !== 'number' || currentIndex < 0) {
        console.error('Invalid currentIndex:', currentIndex);
        alert('Error: No conversation selected. Please refresh the page.');
        return;
    }
    
    try {
        // Check if conversation needs saving
        if (!needsSaving(currentIndex)) {
            button.textContent = 'Already saved!';
            button.classList.add('btn--info');
            
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('btn--info');
            }, 2000);
            return;
        }
        
        // Step 1: Show "AI labeling..." in button
        button.disabled = true;
        button.textContent = 'AI labeling...';
        
        // Step 2: Label current conversation with AI (quiet)
        await runAiLabelingForCurrentQuiet();
        
        // Step 3: Export combined + comparisons for current conversation only
        exportCombinedAndComparisonsForIndex(currentIndex);
        
        // Step 4: Update last save info
        updateLastSaveInfo(currentIndex);
        
        // Step 5: Show "Saved!" briefly
        button.textContent = 'Saved!';
        button.classList.add('btn--success');
        
        // Step 6: Reset button after 2 seconds
        setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('btn--success');
            button.disabled = false;
        }, 2000);
        
    } catch (err) {
        console.error('Save and compare failed', err);
        alert('Failed to save and compare with AI. See console for details.');
        
        // Reset button on error
        button.textContent = originalText;
        button.disabled = false;
    }
}

// Check if conversation needs saving based on last save time and human label changes
function needsSaving(conversationIndex) {
    // Safety check for conversationIndex
    if (typeof conversationIndex !== 'number' || conversationIndex < 0) {
        console.warn('[Save Check] Invalid conversation index:', conversationIndex);
        return false;
    }
    
    const lastSaveKey = `lastSave_${conversationIndex}`;
    const lastSave = localStorage.getItem(lastSaveKey);
    
    if (!lastSave) {
        return true; // Never saved before
    }
    
    try {
        const lastSaveTime = new Date(lastSave).getTime();
        const currentTime = new Date().getTime();
        const timeSinceLastSave = currentTime - lastSaveTime;
        
        // Check if human labels have changed since last save
        const humanLabels = labels[conversationIndex]?.survey || {};
        const lastSaveLabelsKey = `lastSaveLabels_${conversationIndex}`;
        const lastSaveLabels = localStorage.getItem(lastSaveLabelsKey);
        
        if (lastSaveLabels) {
            try {
                const lastLabels = JSON.parse(lastSaveLabels);
                const currentLabels = JSON.stringify(humanLabels);
                
                if (currentLabels !== lastLabels) {
                    console.log(`[Save Check] Human labels changed for conversation ${conversationIndex}, needs saving`);
                    return true;
                }
            } catch (e) {
                console.warn('[Save Check] Error parsing last save labels:', e);
                return true; // If we can't parse, assume we need to save
            }
        }
        
        // Check if it's been more than 1 hour since last save (as a safety net)
        const oneHour = 60 * 60 * 1000;
        if (timeSinceLastSave > oneHour) {
            console.log(`[Save Check] More than 1 hour since last save for conversation ${conversationIndex}, needs saving`);
            return true;
        }
        
        console.log(`[Save Check] Conversation ${conversationIndex} doesn't need saving (last save: ${new Date(lastSaveTime).toLocaleString()})`);
        return false;
    } catch (e) {
        console.warn('[Save Check] Error in needsSaving:', e);
        return true; // If there's an error, assume we need to save
    }
}

// Update last save timestamp and labels for a conversation
function updateLastSaveInfo(conversationIndex) {
    // Safety check for conversationIndex
    if (typeof conversationIndex !== 'number' || conversationIndex < 0) {
        console.warn('[Save Check] Invalid conversation index in updateLastSaveInfo:', conversationIndex);
        return;
    }
    
    try {
        const lastSaveKey = `lastSave_${conversationIndex}`;
        const lastSaveLabelsKey = `lastSaveLabels_${conversationIndex}`;
        
        localStorage.setItem(lastSaveKey, new Date().toISOString());
        localStorage.setItem(lastSaveLabelsKey, JSON.stringify(labels[conversationIndex]?.survey || {}));
        
        console.log(`[Save Check] Updated last save info for conversation ${conversationIndex}`);
    } catch (e) {
        console.error('[Save Check] Error updating last save info:', e);
    }
}

// Manual reset of save status (for debugging/testing)
function resetSaveStatus(conversationIndex) {
    if (conversationIndex === undefined) {
        conversationIndex = currentIndex;
    }
    
    const lastSaveKey = `lastSave_${conversationIndex}`;
    const lastSaveLabelsKey = `lastSaveLabels_${conversationIndex}`;
    
    localStorage.removeItem(lastSaveKey);
    localStorage.removeItem(lastSaveLabelsKey);
    
    console.log(`[Save Check] Reset save status for conversation ${conversationIndex}`);
    updateSaveStatusDisplay();
}

// Make functions available globally for debugging
window.needsSaving = needsSaving;
window.updateLastSaveInfo = updateLastSaveInfo;
window.resetSaveStatus = resetSaveStatus;

// Scroll detection functions
function initializeScrollDetection() {
    // Clean up existing observer
    if (messageObserver) {
        messageObserver.disconnect();
    }
    
    // Create new intersection observer
    messageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const messageIndex = parseInt(entry.target.dataset.messageIndex);
                console.log('Message visible:', messageIndex);
                
                // Only add visual indicator if this message triggers a survey
                const shouldHighlight = shouldHighlightMessage(messageIndex);
                
                // Remove highlight from all messages
                document.querySelectorAll('.message').forEach(msg => {
                    msg.classList.remove('message-current');
                });
                
                // Add highlight only if this message triggers a survey
                if (shouldHighlight) {
                    entry.target.classList.add('message-current');
                }
                
                updateSurveyVisibility(messageIndex);
            }
        });
    }, {
        threshold: 0.5, // Trigger when 50% of message is visible
        rootMargin: '-10% 0px -10% 0px' // Trigger slightly before message is fully visible
    });
    
    // Observe all messages
    const messages = document.querySelectorAll('.message');
    messages.forEach(message => {
        messageObserver.observe(message);
    });
    
    console.log('Scroll detection initialized for', messages.length, 'messages');
    
    // Add a test function to manually trigger survey visibility
    window.testScrollDetection = function() {
        console.log('Testing scroll detection...');
        const messages = document.querySelectorAll('.message');
        console.log('Total messages found:', messages.length);
        
        messages.forEach((msg, index) => {
            const rect = msg.getBoundingClientRect();
            const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
            console.log(`Message ${index + 1}: visible=${isVisible}, top=${rect.top}, bottom=${rect.bottom}`);
        });
    };
}

function shouldHighlightMessage(messageIndex) {
    const messages = document.querySelectorAll('.message');
    const totalMessages = messages.length;
    
    // Highlight message 6 (when turn6 survey appears)
    if (messageIndex === 6) {
        console.log('Highlighting message 6 - turn6 survey trigger');
        return true;
    }
    
    // Highlight the last message (when end survey appears)
    if (messageIndex === totalMessages) {
        console.log('Highlighting last message - end survey trigger');
        return true;
    }
    
    return false;
}

function updateSurveyVisibility(currentMessageIndex) {
    console.log('Updating survey visibility for message:', currentMessageIndex);
    
    const turn6Survey = document.querySelector('.survey-turn6');
    const endSurvey = document.querySelector('.survey-end');
    const messages = document.querySelectorAll('.message');
    const totalMessages = messages.length;
    
    console.log('Total messages:', totalMessages);
    console.log('Turn6 survey found:', !!turn6Survey);
    console.log('End survey found:', !!endSurvey);
    
    // Show turn6 survey when user reaches 6th message
    if (currentMessageIndex >= 6 && turn6Survey) {
        console.log('Showing turn6 survey');
        turn6Survey.style.display = 'block';
        turn6Survey.classList.add('survey-visible');
    }
    
    // Show end survey when user reaches the last message
    if (currentMessageIndex >= totalMessages - 1 && endSurvey) {
        console.log('Showing end survey');
        endSurvey.style.display = 'block';
        endSurvey.classList.add('survey-visible');
    }
}

// Display save status for current conversation
function updateSaveStatusDisplay() {
    const button = document.getElementById('saveCompareBtn');
    if (!button || typeof currentIndex !== 'number' || currentIndex < 0) return;
    
    const lastSaveKey = `lastSave_${currentIndex}`;
    const lastSave = localStorage.getItem(lastSaveKey);
    
    if (lastSave) {
        try {
            const lastSaveTime = new Date(lastSave);
            const timeAgo = getTimeAgo(lastSaveTime);
            button.title = `Last saved: ${lastSaveTime.toLocaleString()} (${timeAgo} ago)`;
            
            // Add visual indicator if recently saved
            if (needsSaving(currentIndex)) {
                button.classList.remove('btn--saved');
            } else {
                button.classList.add('btn--saved');
            }
        } catch (e) {
            console.warn('Error parsing save time in updateSaveStatusDisplay:', e);
            button.title = 'Last saved: recently';
            button.classList.remove('btn--saved');
        }
    } else {
        button.title = 'Not saved yet';
        button.classList.remove('btn--saved');
    }
}

// Helper function to get human-readable time ago
function getTimeAgo(date) {
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
    if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
}

// Event listeners
document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight') {
        e.preventDefault();
        nextConversation();
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        previousConversation();
    }
});

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    loadConversations();
}); 