<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Title Selector</title>
    <link rel="stylesheet" href="styles/theme.css">
    <link rel="stylesheet" href="styles/buttons.css">
    <link rel="stylesheet" href="styles/base.css">
    <link rel="stylesheet" href="styles/dark-mode.css">
    <link rel="stylesheet" href="styles/page.css">
    <link rel="stylesheet" href="styles/top-section.css">
    <link rel="stylesheet" href="styles/conversation-list.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <script src="js/header.js"></script>
    <script>
        // Initialize header for index page
        document.addEventListener('DOMContentLoaded', function() {
            initializeHeader({
                title: 'Select chats',
                stats: 'Select reflective or therapy-like chats that you had with ChatGPT below to label it',
            });
        });
    </script>

    <div class="actions">
        <div class="date-range-section card-section">
            <h2>Auto-filter conversations</h2>
            <p>Label your chats as relevant vs not relevant using LLM to make it easier to select the right chats</p>
            <h3>Filter date range</h3>
            <p>Filter conversations by date range to analyze specific model versions</p>
            
            <div class="date-range-controls">
                <div class="date-presets">
                    <label for="modelPreset">Model Version Preset</label>
                    <select id="modelPreset" onchange="setDateRangeFromDropdown()">
                        <option value="">Select Model Version</option>
                        <optgroup label="GPT-4o Models">
                            <option value="gpt-4o-latest">GPT-4o Latest (Jul 2025+)</option>
                            <option value="gpt-4o-2025">GPT-4o 2025 (Jan 2025-Jun 2025)</option>
                            <option value="gpt-4o-2024">GPT-4o 2024 (May 2024-Dec 2024)</option>
                        </optgroup>
                        <optgroup label="GPT-3.5-turbo Models">
                            <option value="gpt-3.5-turbo-0125">GPT-3.5-turbo-0125 (Apr 2024+)</option>
                            <option value="gpt-3.5-turbo-1106">GPT-3.5-turbo-1106 (Nov 2023-Apr 2024)</option>
                            <option value="gpt-3.5-turbo-16k">GPT-3.5-turbo-16k (Jun 2023-Nov 2023)</option>
                            <option value="gpt-3.5-turbo">GPT-3.5-turbo (Mar 2023-Jun 2023)</option>
                        </optgroup>
                    </select>
                </div>
                <div class="date-input-row">
                    <div class="date-input-group">
                        <label for="startDate">Start Date</label>
                        <input type="date" id="startDate" onchange="updateDateRange()">
                    </div>
                    <div class="date-input-group">
                        <label for="endDate">End Date</label>
                        <input type="date" id="endDate" onchange="updateDateRange()">
                    </div>
                </div>
            </div>
            
            <div class="date-range-info">
                <span id="filteredCount">0</span> conversations in selected date range
            </div>
            <div class="progress-container" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
            
            <button id="analyzeBtn" class="btn btn--accent btn--md" onclick="analyzeWithAI()" disabled>Auto-filter</button>
            <div id="apiKeyStatus" style="margin-top: 8px; font-size: 14px; color: #666;">Loading API key...</div>
        </div>

        <div class="filter-controls">
                    <div class="filter-group">
            <button id="selectAllBtn" class="btn btn--outline" onclick="selectAll()">Select All</button>
            <button id="deselectAllBtn" class="btn btn--outline" onclick="deselectAll()">Deselect all</button>
            <button id="exportBtn" class="btn btn--accent" onclick="exportSelectedConversations()">Export Selected</button>
        </div>
            <div class="filter-group">
                <div class="filter-buttons">
                    <button class="btn btn--chip relevant" data-category="relevant" onclick="filterByCategory('relevant')">Relevant</button>
                    <button class="btn btn--chip not-relevant" data-category="not-relevant" onclick="filterByCategory('not-relevant')">Non-relevant</button>
                </div>
            </div>
        </div>
    </div>

    <div id="conversationList" class="conversation-list">
        <!-- Conversations will be loaded here -->
    </div>

    <script src="js/dark-mode.js"></script>
    <script type="module" src="js/index.js"></script>
    <!-- Legacy inline script retained temporarily for functional parity. To complete refactor, remove below block after verifying external modules cover all features. -->
    <script>
        let conversations = [];
        // Track selected categories (multi-select). Empty Set = show all
        const selectedCategories = new Set();

            function getSearchTerm() {
                const el = document.getElementById('searchInput');
                return (el && el.value ? el.value.toLowerCase() : '');
            }

        async function loadConversations() {
            try {
                const response = await fetch('conversations.json');
                const data = await response.json();
                conversations = data;
                
                // Initialize filtered conversations
                filteredConversations = conversations;
                document.getElementById('filteredCount').textContent = conversations.length;
                
                displayConversations(conversations);
                
                // Update the total conversations count in the header
                const totalElement = document.getElementById('totalConversations');
                if (totalElement) {
                    totalElement.textContent = conversations.length;
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
                document.getElementById('conversationList').innerHTML = 
                    '<p style="color: red;">Error loading conversations. Please check the console for details.</p>';
            }
        }

        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item" onclick="toggleSelection(${index})">
                        <input type="checkbox" id="convo-${index}">
                        <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;">
                            ${escapeHtml(convo.title || 'Untitled Conversation')}
                        </label>
                </div>
            `).join('');
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function toggleSelection(index) {
            const checkbox = document.getElementById(`convo-${index}`);
            checkbox.checked = !checkbox.checked;
            const item = checkbox.parentElement.parentElement;
            item.classList.toggle('selected', checkbox.checked);
        }

        function togglePreview(index) {
            const previewDiv = document.getElementById(`preview-${index}`);
            if (!previewDiv) {
                console.error(`Preview div not found for index ${index}`);
                return;
            }
            
            const isVisible = previewDiv.style.display !== 'none';
            
            if (!isVisible) {
                // Use the currently displayed conversations (filtered or all)
                const displayedConversations = filteredConversations.length > 0 ? filteredConversations : conversations;
                
                // Get the conversation from the displayed list
                const conversation = displayedConversations[index];
                if (!conversation) {
                    console.error(`Conversation not found for index ${index}`);
                    return;
                }
                
                const messages = extractMessages(conversation);
                
                let html = '';
                messages.forEach(message => {
                    const role = message.role;
                    const content = message.content;
                    
                    if (role === 'system' || !content || content.trim() === '') {
                        return;
                    }
                    
                    html += `
                        <div class="preview-message ${role}">
                            <div class="preview-avatar ${role}">${role === 'user' ? 'U' : 'A'}</div>
                            <div class="preview-content">${escapeHtml(content.substring(0, 200))}${content.length > 200 ? '...' : ''}</div>
                        </div>
                    `;
                });
                
                const messagesContainer = previewDiv.querySelector('.preview-messages');
                if (messagesContainer) {
                    messagesContainer.innerHTML = html;
                }
                previewDiv.style.display = 'block';
            } else {
                previewDiv.style.display = 'none';
            }
        }

        function extractMessages(conversation) {
            const messages = [];
            
            if (!conversation.mapping) {
                return messages;
            }
            
            // Get all nodes and sort them by creation time
            const allNodes = Object.values(conversation.mapping).filter(node => 
                node.message && 
                node.message.content && 
                node.message.content.content_type === 'text' &&
                node.message.content.parts?.[0]?.trim() !== ''
            );
            
            // Sort by creation time to get chronological order
            allNodes.sort((a, b) => {
                const timeA = a.message.create_time || 0;
                const timeB = b.message.create_time || 0;
                return timeA - timeB;
            });
            
            allNodes.forEach(node => {
                const role = node.message.author?.role || 'user';
                const content = node.message.content.parts?.[0] || '';
                
                if (content && content.trim() !== '') {
                    messages.push({
                        role: role,
                        content: content.trim()
                    });
                }
            });
            
            return messages;
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            });
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            });
        }

        function saveSelection() {
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (which might be filtered)
            const displayedConversations = conversations.filter(convo => {
                const searchTerm = getSearchTerm();
                const isAll = selectedCategories.size === 0;
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                return matchesSearch && matchesCategory;
            });
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(selectedConversations, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected_conversations.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportSelectedConversations() {
            // Get all manually selected conversations (using checkboxes)
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (filtered or all)
            const displayedConversations = filteredConversations.length > 0 ? filteredConversations : conversations;
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            if (selectedConversations.length === 0) {
                alert('No conversations selected. Please select the conversations you want to export for labeling.');
                return;
            }
            
            // Add metadata about the export
            const exportData = {
                exportDate: new Date().toISOString(),
                totalSelectedConversations: selectedConversations.length,
                totalConversations: conversations.length,
                selectedIndices: selectedIndices,
                conversations: selectedConversations
            };
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected_conversations_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Also save to the current directory via server
            fetch('/save-export', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportData)
            }).catch(error => {
                console.log('Could not save to server directory:', error);
            });
            
            alert(`Exported ${selectedConversations.length} selected conversations for labeling!`);
        }

        // Search functionality (guarded if search input exists)
        (function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', filterConversations);
            }
        })();

        let apiKey = null;

        async function loadApiKey() {
            try {
                const response = await fetch('/api-key');
                const data = await response.json();
                if (data.apiKey) {
                    apiKey = data.apiKey;
                    const status = document.getElementById('apiKeyStatus');
                    if (status) status.textContent = 'API key loaded';
                    const btn = document.getElementById('analyzeBtn');
                    if (btn) btn.disabled = false;
                } else {
                    throw new Error('No API key found');
                }
            } catch (error) {
                console.error('Error loading API key:', error);
                const status = document.getElementById('apiKeyStatus');
                if (status) status.textContent = 'API key not found. Check .env file';
                const btn = document.getElementById('analyzeBtn');
                if (btn) btn.disabled = true;
            }
        }

        async function analyzeWithAI() {
            if (!apiKey) {
                alert('API key not loaded. Please check your .env file and restart the server.');
                return;
            }

            // Use filtered conversations if date range is set, otherwise use all conversations
            const conversationsToAnalyze = filteredConversations.length > 0 ? filteredConversations : conversations;
            
            if (conversationsToAnalyze.length === 0) {
                alert('No conversations to analyze. Please check your date range filter.');
                return;
            }

            const button = document.getElementById('analyzeBtn');
            const progressContainer = document.querySelector('.progress-container');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            button.disabled = true;
            button.textContent = 'Analyzing...';
            progressContainer.style.display = 'block';
            
            // Add progress tracking
            let processedCount = 0;
            const totalCount = conversationsToAnalyze.length;

            try {
                // Process conversations in batches of 20 to avoid rate limits
                const batchSize = 20;
                for (let i = 0; i < conversationsToAnalyze.length; i += batchSize) {
                    const batch = conversationsToAnalyze.slice(i, i + batchSize);
                    
                    // Extract first user message from each conversation
                    const conversationSamples = batch.map(conv => {
                        const messages = extractMessages(conv);
                        const firstUserMessage = messages.find(msg => msg.role === 'user');
                        const sample = firstUserMessage ? firstUserMessage.content.substring(0, 400) : (conv.title || 'Untitled Conversation');
                        return {
                            title: conv.title || 'Untitled Conversation',
                            sample: sample
                        };
                    });
                    
                    console.log('Sending request to OpenAI with API key:', apiKey.substring(0, 10) + '...');
                    
                    const requestBody = {
                        model: "gpt-3.5-turbo",
                        messages: [{
                            role: "system",
                            content: "You are helping to identify conversations that might be relevant for reflective or therapy-like conversations with ChatGPT. Look for conversations about personal growth, emotions, relationships, self-reflection, mental health, or similar topics. You must respond with ONLY a valid JSON array with exactly the same number of items as conversations provided, no other text."
                        }, {
                            role: "user",
                            content: `Analyze these ${conversationSamples.length} conversations and determine if each is relevant for reflective/therapy-like conversations with ChatGPT. Look for topics like personal growth, emotions, relationships, self-reflection, mental health, or similar.

For each conversation, I'll provide the title and a sample of the first user message (up to 400 characters).

IMPORTANT: You must respond with exactly ${conversationSamples.length} classifications in a JSON array, one for each conversation provided.

Each object must have exactly these fields:
- "category": either "relevant" or "not-relevant"
- "explanation": a brief reason for the classification

Example format:
[{"category": "relevant", "explanation": "This appears to be about personal relationships"}, {"category": "not-relevant", "explanation": "This is about technical programming"}]

Conversations to analyze: ${JSON.stringify(conversationSamples)}`
                        }]
                    };
                    
                    console.log('Request body:', requestBody);
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();
                    console.log('OpenAI response status:', response.status);
                    console.log('OpenAI response data:', data);
                    
                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${data.error?.message || response.statusText} (Status: ${response.status})`);
                    }
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Unexpected response format from OpenAI API');
                    }
                    
                    let classifications;
                    try {
                        classifications = JSON.parse(data.choices[0].message.content);
                        console.log('Parsed classifications:', classifications);
                        
                        // Validate that we got the expected number of classifications
                        if (!Array.isArray(classifications)) {
                            throw new Error('Response is not an array');
                        }
                        
                        if (classifications.length !== batch.length) {
                            console.warn(`Expected ${batch.length} classifications but got ${classifications.length}`);
                            // Pad with default classifications if we got fewer than expected
                            while (classifications.length < batch.length) {
                                classifications.push({
                                    category: 'not-relevant',
                                    explanation: 'Failed to classify - missing from AI response'
                                });
                            }
                        }
                    } catch (parseError) {
                        console.error('Error parsing OpenAI response:', parseError);
                        console.log('Raw response content:', data.choices[0].message.content);
                        throw new Error('Failed to parse OpenAI response. The AI may not have returned valid JSON.');
                    }
                    
                    // Add classifications to conversations
                    batch.forEach((conv, index) => {
                        if (index < classifications.length && classifications[index] && classifications[index].category) {
                            conv.aiCategory = classifications[index].category;
                            conv.aiExplanation = classifications[index].explanation || '';
                        } else {
                            console.warn(`Missing classification for conversation ${index}:`, classifications[index]);
                            conv.aiCategory = 'not-relevant';
                            conv.aiExplanation = 'Failed to classify';
                        }
                    });

                    // Update display after each batch
                    displayConversations(conversationsToAnalyze);
                    
                    // Update progress
                    processedCount += batch.length;
                    const progressPercent = Math.round((processedCount / totalCount) * 100);
                    progressFill.style.width = `${progressPercent}%`;
                    progressText.textContent = `${processedCount}/${totalCount} (${progressPercent}%)`;
                    button.textContent = `Analyzing... ${processedCount}/${totalCount}`;
                    
                    // Small delay between batches to avoid rate limiting
                    if (i + batchSize < conversationsToAnalyze.length) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
            } catch (error) {
                console.error('Error analyzing with AI:', error);
                let errorMessage = 'Error analyzing conversations. ';
                if (error.message.includes('rate limit')) {
                    errorMessage += 'Rate limit exceeded. Please wait a moment and try again.';
                } else if (error.message.includes('API key')) {
                    errorMessage += 'Invalid API key. Please check your configuration.';
                } else if (error.message.includes('Failed to parse')) {
                    errorMessage += 'AI response was invalid. Please try again.';
                } else {
                    errorMessage += 'Check console for details.';
                }
                alert(errorMessage);
            } finally {
                button.disabled = false;
                button.textContent = 'Auto-filter';
                progressContainer.style.display = 'none';
                progressFill.style.width = '0%';
                progressText.textContent = '0%';
            }
        }

        function syncFilterButtonsUI() {
            document.querySelectorAll('.btn--chip').forEach(btn => {
                const cat = btn.dataset.category;
                if (selectedCategories.has(cat)) {
                    btn.classList.add('is-active');
                } else {
                    btn.classList.remove('is-active');
                }
            });
        }

        function filterByCategory(category) {
            if (selectedCategories.has(category)) {
                selectedCategories.delete(category); // deselect
            } else {
                selectedCategories.add(category); // select
            }
            syncFilterButtonsUI();
            filterConversations();
        }

        function filterConversations() {
            const searchTerm = getSearchTerm();
            const isAll = selectedCategories.size === 0; // none selected means show all
            const filteredConvos = conversations.filter(convo => {
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                return matchesSearch && matchesCategory;
            });
            displayConversations(filteredConvos);
        }

        // Update display function to show AI classifications
        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item">
                    <div class="conversation-header">
                        <input type="checkbox" id="convo-${index}" onclick="event.stopPropagation()">
                        <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;" onclick="toggleSelection(${index})">
                            <div class="conversation-title">
                                ${escapeHtml(convo.title || 'Untitled Conversation')}
                                ${convo.aiCategory ? 
                                    `<span class="category-tag ${convo.aiCategory}">${
                                        convo.aiCategory === 'relevant' ? 'Relevant' : 'Not Relevant'
                                    }</span>` 
                                    : ''}
                            </div>
                            <div class="conversation-meta">
                                <small style="color: #666;">Created: ${formatDate(convo.create_time)}</small>
                                ${convo.aiExplanation ? 
                                    `<br><small style="color: #666;">${escapeHtml(convo.aiExplanation)}</small>` 
                                    : ''}
                            </div>
                        </label>
                        <button onclick="event.stopPropagation(); togglePreview(${index})" class="btn btn--icon">👁️ Preview</button>
                    </div>
                    <div id="preview-${index}" class="conversation-preview" style="display: none;">
                        <div class="preview-messages"></div>
                    </div>
                </div>
            `).join('');
        }

        // Update search to use new filter function (guarded if element exists)
        (function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', filterConversations);
            }
        })();

        // Date range filtering
        let filteredConversations = [];
        let dateRangeStart = null;
        let dateRangeEnd = null;

        function updateDateRange() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            dateRangeStart = startDate ? new Date(startDate).getTime() / 1000 : null;
            dateRangeEnd = endDate ? new Date(endDate + 'T23:59:59').getTime() / 1000 : null;
            
            filterConversationsByDate();
        }

        function setDateRange(modelVersion) {
            const ranges = {
                'gpt-4o-latest': { start: '2025-07-01', end: '2025-12-31' },
                'gpt-4o-2025': { start: '2025-01-01', end: '2025-06-30' },
                'gpt-4o-2024': { start: '2024-05-01', end: '2024-12-31' },
                'gpt-3.5-turbo-0125': { start: '2024-04-01', end: '2025-12-31' },
                'gpt-3.5-turbo-1106': { start: '2023-11-01', end: '2024-03-31' },
                'gpt-3.5-turbo-16k': { start: '2023-06-01', end: '2023-10-31' },
                'gpt-3.5-turbo': { start: '2023-03-01', end: '2023-05-31' }
            };
            
            const range = ranges[modelVersion];
            if (range) {
                document.getElementById('startDate').value = range.start;
                document.getElementById('endDate').value = range.end;
                updateDateRange();
            }
        }

        function setDateRangeFromDropdown() {
            const select = document.getElementById('modelPreset');
            const selectedValue = select.value;
            
            if (selectedValue) {
                setDateRange(selectedValue);
            }
        }

        function filterConversationsByDate() {
            filteredConversations = conversations.filter(convo => {
                const createTime = convo.create_time;
                if (!createTime) return false;
                
                if (dateRangeStart && createTime < dateRangeStart) return false;
                if (dateRangeEnd && createTime > dateRangeEnd) return false;
                
                return true;
            });
            
            document.getElementById('filteredCount').textContent = filteredConversations.length;
            displayConversations(filteredConversations);
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString();
        }

        // Load conversations and API key when the page loads
        loadConversations();
        loadApiKey();
        
        // Initialize dark mode
        if (typeof createDarkModeToggle === 'function') {
            createDarkModeToggle();
        }
    </script>
</body>
</html>