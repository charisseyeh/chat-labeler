<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Title Selector</title>
    <link rel="stylesheet" href="styles/theme.css">
    <link rel="stylesheet" href="styles/buttons.css">
    <link rel="stylesheet" href="styles/base.css">
    <link rel="stylesheet" href="styles/dark-mode.css">
    <link rel="stylesheet" href="styles/page.css">
    <link rel="stylesheet" href="styles/top-section.css">
    <link rel="stylesheet" href="styles/conversation-list.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <script src="js/header.js"></script>
    <script>
        // Initialize header for index page
        document.addEventListener('DOMContentLoaded', function() {
            initializeHeader({
                title: 'Select chats',
                stats: 'Select reflective or therapy-like chats that you had with ChatGPT below to label it',
            });
        });
    </script>

    <div class="actions">
        <div class="auto-filter-section card-section">
            <h2>Auto-filter conversations</h2>
            <p>Label your chats as relevant vs not relevant using LLM to make it easier to select the right chats</p>

            <button id="analyzeBtn" class="btn btn--accent btn--md" onclick="analyzeWithAI()">Auto-filter</button>
        </div>
        <div class="filter-controls">
                    <div class="filter-group">
            <button id="selectAllBtn" class="btn btn--outline" onclick="selectAll()">Select All</button>
            <button id="deselectAllBtn" class="btn btn--outline" onclick="deselectAll()">Deselect all</button>
            <button id="exportBtn" class="btn btn--accent" onclick="exportSelectedConversations()">Export Selected</button>
        </div>
            <div class="filter-group">
                <div class="filter-buttons">
                    <button class="btn btn--chip relevant" data-category="relevant" onclick="filterByCategory('relevant')">Relevant</button>
                    <button class="btn btn--chip not-relevant" data-category="not-relevant" onclick="filterByCategory('not-relevant')">Non-relevant</button>
                </div>
            </div>
        </div>
    </div>

    <div id="conversationList" class="conversation-list">
        <!-- Conversations will be loaded here -->
    </div>

    <script src="js/dark-mode.js"></script>
    <script type="module" src="js/index.js"></script>
    <!-- Legacy inline script retained temporarily for functional parity. To complete refactor, remove below block after verifying external modules cover all features. -->
    <script>
        let conversations = [];
        // Track selected categories (multi-select). Empty Set = show all
        const selectedCategories = new Set();

            function getSearchTerm() {
                const el = document.getElementById('searchInput');
                return (el && el.value ? el.value.toLowerCase() : '');
            }

        async function loadConversations() {
            try {
                const response = await fetch('conversations.json');
                const data = await response.json();
                conversations = data;
                displayConversations(conversations);
                
                // Update the total conversations count in the header
                const totalElement = document.getElementById('totalConversations');
                if (totalElement) {
                    totalElement.textContent = conversations.length;
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
                document.getElementById('conversationList').innerHTML = 
                    '<p style="color: red;">Error loading conversations. Please check the console for details.</p>';
            }
        }

        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item" onclick="toggleSelection(${index})">
                        <input type="checkbox" id="convo-${index}">
                        <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;">
                            ${escapeHtml(convo.title || 'Untitled Conversation')}
                        </label>
                </div>
            `).join('');
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function toggleSelection(index) {
            const checkbox = document.getElementById(`convo-${index}`);
            checkbox.checked = !checkbox.checked;
            const item = checkbox.parentElement.parentElement;
            item.classList.toggle('selected', checkbox.checked);
        }

        function togglePreview(index) {
            const previewDiv = document.getElementById(`preview-${index}`);
            const isVisible = previewDiv.style.display !== 'none';
            
            if (!isVisible) {
                // Get the currently displayed conversations (which might be filtered)
                const displayedConversations = conversations.filter(convo => {
                    const searchTerm = getSearchTerm();
                    const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                    const isAll = selectedCategories.size === 0;
                    const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                    return matchesSearch && matchesCategory;
                });
                
                // Get the conversation from the filtered list
                const conversation = displayedConversations[index];
                const messages = extractMessages(conversation);
                
                let html = '';
                messages.forEach(message => {
                    const role = message.role;
                    const content = message.content;
                    
                    if (role === 'system' || !content || content.trim() === '') {
                        return;
                    }
                    
                    html += `
                        <div class="preview-message ${role}">
                            <div class="preview-avatar ${role}">${role === 'user' ? 'U' : 'A'}</div>
                            <div class="preview-content">${escapeHtml(content.substring(0, 200))}${content.length > 200 ? '...' : ''}</div>
                        </div>
                    `;
                });
                
                previewDiv.querySelector('.preview-messages').innerHTML = html;
                previewDiv.style.display = 'block';
            } else {
                previewDiv.style.display = 'none';
            }
        }

        function extractMessages(conversation) {
            const messages = [];
            
            if (!conversation.mapping) {
                return messages;
            }
            
            // Get all nodes and sort them by creation time
            const allNodes = Object.values(conversation.mapping).filter(node => 
                node.message && 
                node.message.content && 
                node.message.content.content_type === 'text' &&
                node.message.content.parts?.[0]?.trim() !== ''
            );
            
            // Sort by creation time to get chronological order
            allNodes.sort((a, b) => {
                const timeA = a.message.create_time || 0;
                const timeB = b.message.create_time || 0;
                return timeA - timeB;
            });
            
            allNodes.forEach(node => {
                const role = node.message.author?.role || 'user';
                const content = node.message.content.parts?.[0] || '';
                
                if (content && content.trim() !== '') {
                    messages.push({
                        role: role,
                        content: content.trim()
                    });
                }
            });
            
            return messages;
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            });
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            });
        }

        function saveSelection() {
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (which might be filtered)
            const displayedConversations = conversations.filter(convo => {
                const searchTerm = getSearchTerm();
                const isAll = selectedCategories.size === 0;
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                return matchesSearch && matchesCategory;
            });
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(selectedConversations, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected_conversations.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportSelectedConversations() {
            // Get all manually selected conversations (using checkboxes)
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (which might be filtered)
            const displayedConversations = conversations.filter(convo => {
                const searchTerm = getSearchTerm();
                const isAll = selectedCategories.size === 0;
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                return matchesSearch && matchesCategory;
            });
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            if (selectedConversations.length === 0) {
                alert('No conversations selected. Please select the conversations you want to export for labeling.');
                return;
            }
            
            // Add metadata about the export
            const exportData = {
                exportDate: new Date().toISOString(),
                totalSelectedConversations: selectedConversations.length,
                totalConversations: conversations.length,
                selectedIndices: selectedIndices,
                conversations: selectedConversations
            };
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected_conversations_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Also save to the current directory via server
            fetch('/save-export', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportData)
            }).catch(error => {
                console.log('Could not save to server directory:', error);
            });
            
            alert(`Exported ${selectedConversations.length} selected conversations for labeling!`);
        }

        // Search functionality (guarded if search input exists)
        (function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', filterConversations);
            }
        })();

        let apiKey = null;

        async function loadApiKey() {
            try {
                const response = await fetch('/api-key');
                const data = await response.json();
                if (data.apiKey) {
                    apiKey = data.apiKey;
                    document.getElementById('apiKeyStatus').textContent = '✅ API key loaded';
                    document.getElementById('analyzeBtn').disabled = false;
                } else {
                    throw new Error('No API key found');
                }
            } catch (error) {
                console.error('Error loading API key:', error);
                document.getElementById('apiKeyStatus').textContent = '❌ API key not found. Check .env file';
                document.getElementById('analyzeBtn').disabled = true;
            }
        }

        async function analyzeWithAI() {
            if (!apiKey) {
                alert('API key not loaded. Please check your .env file and restart the server.');
                return;
            }

            const button = document.getElementById('analyzeBtn');
            button.disabled = true;
            button.textContent = 'Analyzing...';

            try {
                // Process conversations in batches of 20 to avoid rate limits
                const batchSize = 20;
                for (let i = 0; i < conversations.length; i += batchSize) {
                    const batch = conversations.slice(i, i + batchSize);
                    
                    // Extract first user message from each conversation
                    const conversationSamples = batch.map(conv => {
                        const messages = extractMessages(conv);
                        const firstUserMessage = messages.find(msg => msg.role === 'user');
                        const sample = firstUserMessage ? firstUserMessage.content.substring(0, 400) : (conv.title || 'Untitled Conversation');
                        return {
                            title: conv.title || 'Untitled Conversation',
                            sample: sample
                        };
                    });
                    
                    console.log('Sending request to OpenAI with API key:', apiKey.substring(0, 10) + '...');
                    
                    const requestBody = {
                        model: "gpt-3.5-turbo",
                                                    messages: [{
                                role: "system",
                                content: "You are helping to identify conversations that might be relevant for reflective or therapy-like conversations with ChatGPT. Look for conversations about personal growth, emotions, relationships, self-reflection, mental health, or similar topics. You must respond with ONLY a valid JSON array, no other text."
                            }, {
                                role: "user",
                                content: `Analyze these conversations and determine if each is relevant for reflective/therapy-like conversations with ChatGPT. Look for topics like personal growth, emotions, relationships, self-reflection, mental health, or similar.

For each conversation, I'll provide the title and a sample of the first user message (up to 400 characters).

Respond with ONLY a JSON array where each object has exactly these fields:
- "category": either "relevant" or "not-relevant"
- "explanation": a brief reason for the classification

Example format:
[{"category": "relevant", "explanation": "This appears to be about personal relationships"}, {"category": "not-relevant", "explanation": "This is about technical programming"}]

Conversations to analyze: ${JSON.stringify(conversationSamples)}`
                            }]
                    };
                    
                    console.log('Request body:', requestBody);
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();
                    console.log('OpenAI response status:', response.status);
                    console.log('OpenAI response data:', data);
                    
                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${data.error?.message || response.statusText} (Status: ${response.status})`);
                    }
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Unexpected response format from OpenAI API');
                    }
                    
                    let classifications;
                    try {
                        classifications = JSON.parse(data.choices[0].message.content);
                        console.log('Parsed classifications:', classifications);
                    } catch (parseError) {
                        console.error('Error parsing OpenAI response:', parseError);
                        console.log('Raw response content:', data.choices[0].message.content);
                        throw new Error('Failed to parse OpenAI response. The AI may not have returned valid JSON.');
                    }
                    
                    // Add classifications to conversations
                    batch.forEach((conv, index) => {
                        if (classifications[index] && classifications[index].category) {
                            conv.aiCategory = classifications[index].category;
                            conv.aiExplanation = classifications[index].explanation || '';
                        } else {
                            console.warn(`Missing classification for conversation ${index}:`, classifications[index]);
                            conv.aiCategory = 'not-relevant';
                            conv.aiExplanation = 'Failed to classify';
                        }
                    });

                    // Update display after each batch
                    displayConversations(conversations);
                }
            } catch (error) {
                console.error('Error analyzing with AI:', error);
                alert('Error analyzing conversations. Check console for details.');
            } finally {
                button.disabled = false;
                button.textContent = 'Auto-filter';
            }
        }

        function syncFilterButtonsUI() {
            document.querySelectorAll('.btn--chip').forEach(btn => {
                const cat = btn.dataset.category;
                if (selectedCategories.has(cat)) {
                    btn.classList.add('is-active');
                } else {
                    btn.classList.remove('is-active');
                }
            });
        }

        function filterByCategory(category) {
            if (selectedCategories.has(category)) {
                selectedCategories.delete(category); // deselect
            } else {
                selectedCategories.add(category); // select
            }
            syncFilterButtonsUI();
            filterConversations();
        }

        function filterConversations() {
            const searchTerm = getSearchTerm();
            const isAll = selectedCategories.size === 0; // none selected means show all
            const filteredConvos = conversations.filter(convo => {
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = isAll || (convo.aiCategory && selectedCategories.has(convo.aiCategory));
                return matchesSearch && matchesCategory;
            });
            displayConversations(filteredConvos);
        }

        // Update display function to show AI classifications
        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item">
                    <div class="conversation-header">
                        <input type="checkbox" id="convo-${index}" onclick="event.stopPropagation()">
                        <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;" onclick="toggleSelection(${index})">
                            ${escapeHtml(convo.title || 'Untitled Conversation')}
                            ${convo.aiCategory ? 
                                `<span class="category-tag ${convo.aiCategory}">${
                                    convo.aiCategory === 'relevant' ? 'Relevant' : 'Not Relevant'
                                }</span>` 
                                : ''}
                            ${convo.aiExplanation ? 
                                `<br><small style="color: #666;">${escapeHtml(convo.aiExplanation)}</small>` 
                                : ''}
                        </label>
                        <button onclick="event.stopPropagation(); togglePreview(${index})" class="btn btn--icon">👁️ Preview</button>
                    </div>
                    <div id="preview-${index}" class="conversation-preview" style="display: none;">
                        <div class="preview-messages"></div>
                    </div>
                </div>
            `).join('');
        }

        // Update search to use new filter function (guarded if element exists)
        (function() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', filterConversations);
            }
        })();

        // Load conversations and API key when the page loads
        loadConversations();
        loadApiKey();
        
        // Initialize dark mode
        if (typeof createDarkModeToggle === 'function') {
            createDarkModeToggle();
        }
    </script>
</body>
</html>