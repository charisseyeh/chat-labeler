<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Title Selector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
        }
        .conversation-list {
            margin: 20px 0;
        }
        .conversation-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .conversation-item:hover {
            background-color: #f5f5f5;
        }
        .actions {
            position: sticky;
            top: 0;
            background: white;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
        }
        .selected {
            background-color: #e3f2fd;
        }
        
        .conversation-header {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .preview-btn {
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .preview-btn:hover {
            background: #e0e0e0;
        }
        
        .conversation-preview {
            background: #f9f9f9;
            border-top: 1px solid #eee;
            padding: 15px;
            margin-top: 5px;
        }
        
        .preview-messages {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .preview-message {
            margin-bottom: 10px;
            display: flex;
            gap: 8px;
        }
        
        .preview-message.user {
            flex-direction: row-reverse;
        }
        
        .preview-message.assistant {
            flex-direction: row;
        }
        
        .preview-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
        }
        
        .preview-avatar.user {
            background: #10a37f;
            color: white;
        }
        
        .preview-avatar.assistant {
            background: #f7f7f8;
            color: #374151;
        }
        
        .preview-content {
            flex: 1;
            max-width: 70%;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .preview-message.user .preview-content {
            background: #10a37f;
            color: white;
        }
        
        .preview-message.assistant .preview-content {
            background: #f7f7f8;
            color: #374151;
        }
    </style>
</head>
<body>
    <h1>Conversation Title Selector</h1>
    
    <div class="actions">
        <div class="api-key-section" style="margin-bottom: 15px;">
            <button onclick="analyzeWithAI()" id="analyzeBtn">Analyze Titles with AI</button>
            <span id="apiKeyStatus" style="margin-left: 10px; color: #666;"></span>
        </div>
        <div class="filters" style="margin-bottom: 15px;">
            <select id="categoryFilter" onchange="filterConversations()" style="padding: 8px; margin-right: 10px;">
                <option value="all">All Conversations</option>
                <option value="relevant">Relevant for Reflection</option>
                <option value="not-relevant">Not Relevant</option>
            </select>
            <input type="text" class="search-box" placeholder="Search titles..." id="searchInput">
        </div>
        <div>
            <button onclick="selectAll()">Select All</button>
            <button onclick="deselectAll()">Deselect All</button>
            <button onclick="saveSelection()">Save Selection</button>
            <button onclick="exportSelectedConversations()" style="background-color: #4CAF50; color: white;">Export Selected for Labeling</button>
        </div>
    </div>

    <div id="conversationList" class="conversation-list">
        <!-- Conversations will be loaded here -->
    </div>

    <script>
        let conversations = [];

        async function loadConversations() {
            try {
                const response = await fetch('conversations.json');
                const data = await response.json();
                conversations = data;
                displayConversations(conversations);
            } catch (error) {
                console.error('Error loading conversations:', error);
                document.getElementById('conversationList').innerHTML = 
                    '<p style="color: red;">Error loading conversations. Please check the console for details.</p>';
            }
        }

        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item" onclick="toggleSelection(${index})">
                    <input type="checkbox" id="convo-${index}">
                    <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;">
                        ${escapeHtml(convo.title || 'Untitled Conversation')}
                    </label>
                </div>
            `).join('');
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function toggleSelection(index) {
            const checkbox = document.getElementById(`convo-${index}`);
            checkbox.checked = !checkbox.checked;
            const item = checkbox.parentElement.parentElement;
            item.classList.toggle('selected', checkbox.checked);
        }

        function togglePreview(index) {
            const previewDiv = document.getElementById(`preview-${index}`);
            const isVisible = previewDiv.style.display !== 'none';
            
            if (!isVisible) {
                // Get the currently displayed conversations (which might be filtered)
                const displayedConversations = conversations.filter(convo => {
                    const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                    const category = document.getElementById('categoryFilter').value;
                    
                    const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                    const matchesCategory = category === 'all' || (convo.aiCategory && convo.aiCategory === category);
                    return matchesSearch && matchesCategory;
                });
                
                // Get the conversation from the filtered list
                const conversation = displayedConversations[index];
                const messages = extractMessages(conversation);
                
                let html = '';
                messages.forEach(message => {
                    const role = message.role;
                    const content = message.content;
                    
                    if (role === 'system' || !content || content.trim() === '') {
                        return;
                    }
                    
                    html += `
                        <div class="preview-message ${role}">
                            <div class="preview-avatar ${role}">${role === 'user' ? 'U' : 'A'}</div>
                            <div class="preview-content">${escapeHtml(content.substring(0, 200))}${content.length > 200 ? '...' : ''}</div>
                        </div>
                    `;
                });
                
                previewDiv.querySelector('.preview-messages').innerHTML = html;
                previewDiv.style.display = 'block';
            } else {
                previewDiv.style.display = 'none';
            }
        }

        function extractMessages(conversation) {
            const messages = [];
            
            if (!conversation.mapping) {
                return messages;
            }
            
            // Get all nodes and sort them by creation time
            const allNodes = Object.values(conversation.mapping).filter(node => 
                node.message && 
                node.message.content && 
                node.message.content.content_type === 'text' &&
                node.message.content.parts?.[0]?.trim() !== ''
            );
            
            // Sort by creation time to get chronological order
            allNodes.sort((a, b) => {
                const timeA = a.message.create_time || 0;
                const timeB = b.message.create_time || 0;
                return timeA - timeB;
            });
            
            allNodes.forEach(node => {
                const role = node.message.author?.role || 'user';
                const content = node.message.content.parts?.[0] || '';
                
                if (content && content.trim() !== '') {
                    messages.push({
                        role: role,
                        content: content.trim()
                    });
                }
            });
            
            return messages;
        }

        function selectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            });
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            });
        }

        function saveSelection() {
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (which might be filtered)
            const displayedConversations = conversations.filter(convo => {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const category = document.getElementById('categoryFilter').value;
                
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = category === 'all' || (convo.aiCategory && convo.aiCategory === category);
                return matchesSearch && matchesCategory;
            });
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(selectedConversations, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected_conversations.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportSelectedConversations() {
            // Get all manually selected conversations (using checkboxes)
            const selectedIndices = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .map((checkbox, index) => checkbox.checked ? index : null)
                .filter(index => index !== null);
            
            // Get the currently displayed conversations (which might be filtered)
            const displayedConversations = conversations.filter(convo => {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const category = document.getElementById('categoryFilter').value;
                
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = category === 'all' || (convo.aiCategory && convo.aiCategory === category);
                return matchesSearch && matchesCategory;
            });
            
            // Map the selected indices to the actual conversations from the original array
            const selectedConversations = selectedIndices.map(index => {
                const selectedConvo = displayedConversations[index];
                // Find the original index in the full conversations array
                const originalIndex = conversations.findIndex(conv => conv === selectedConvo);
                return conversations[originalIndex];
            });
            
            if (selectedConversations.length === 0) {
                alert('No conversations selected. Please select the conversations you want to export for labeling.');
                return;
            }
            
            // Add metadata about the export
            const exportData = {
                exportDate: new Date().toISOString(),
                totalSelectedConversations: selectedConversations.length,
                totalConversations: conversations.length,
                selectedIndices: selectedIndices,
                conversations: selectedConversations
            };
            
            // Create a download link for the selected conversations
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected_conversations_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Also save to the current directory via server
            fetch('/save-export', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(exportData)
            }).catch(error => {
                console.log('Could not save to server directory:', error);
            });
            
            alert(`Exported ${selectedConversations.length} selected conversations for labeling!`);
        }

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', function(e) {
            filterConversations();
        });

        let apiKey = null;

        async function loadApiKey() {
            try {
                const response = await fetch('/api-key');
                const data = await response.json();
                if (data.apiKey) {
                    apiKey = data.apiKey;
                    document.getElementById('apiKeyStatus').textContent = '✅ API key loaded';
                    document.getElementById('analyzeBtn').disabled = false;
                } else {
                    throw new Error('No API key found');
                }
            } catch (error) {
                console.error('Error loading API key:', error);
                document.getElementById('apiKeyStatus').textContent = '❌ API key not found. Check .env file';
                document.getElementById('analyzeBtn').disabled = true;
            }
        }

        async function analyzeWithAI() {
            if (!apiKey) {
                alert('API key not loaded. Please check your .env file and restart the server.');
                return;
            }

            const button = document.querySelector('button[onclick="analyzeWithAI()"]');
            button.disabled = true;
            button.textContent = 'Analyzing...';

            try {
                // Process conversations in batches of 20 to avoid rate limits
                const batchSize = 20;
                for (let i = 0; i < conversations.length; i += batchSize) {
                    const batch = conversations.slice(i, i + batchSize);
                    
                    // Extract first user message from each conversation
                    const conversationSamples = batch.map(conv => {
                        const messages = extractMessages(conv);
                        const firstUserMessage = messages.find(msg => msg.role === 'user');
                        const sample = firstUserMessage ? firstUserMessage.content.substring(0, 400) : (conv.title || 'Untitled Conversation');
                        return {
                            title: conv.title || 'Untitled Conversation',
                            sample: sample
                        };
                    });
                    
                    console.log('Sending request to OpenAI with API key:', apiKey.substring(0, 10) + '...');
                    
                    const requestBody = {
                        model: "gpt-3.5-turbo",
                                                    messages: [{
                                role: "system",
                                content: "You are helping to identify conversations that might be relevant for reflective or therapy-like conversations with ChatGPT. Look for conversations about personal growth, emotions, relationships, self-reflection, mental health, or similar topics. You must respond with ONLY a valid JSON array, no other text."
                            }, {
                                role: "user",
                                content: `Analyze these conversations and determine if each is relevant for reflective/therapy-like conversations with ChatGPT. Look for topics like personal growth, emotions, relationships, self-reflection, mental health, or similar.

For each conversation, I'll provide the title and a sample of the first user message (up to 400 characters).

Respond with ONLY a JSON array where each object has exactly these fields:
- "category": either "relevant" or "not-relevant"
- "explanation": a brief reason for the classification

Example format:
[{"category": "relevant", "explanation": "This appears to be about personal relationships"}, {"category": "not-relevant", "explanation": "This is about technical programming"}]

Conversations to analyze: ${JSON.stringify(conversationSamples)}`
                            }]
                    };
                    
                    console.log('Request body:', requestBody);
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const data = await response.json();
                    console.log('OpenAI response status:', response.status);
                    console.log('OpenAI response data:', data);
                    
                    if (!response.ok) {
                        throw new Error(`OpenAI API error: ${data.error?.message || response.statusText} (Status: ${response.status})`);
                    }
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Unexpected response format from OpenAI API');
                    }
                    
                    let classifications;
                    try {
                        classifications = JSON.parse(data.choices[0].message.content);
                        console.log('Parsed classifications:', classifications);
                    } catch (parseError) {
                        console.error('Error parsing OpenAI response:', parseError);
                        console.log('Raw response content:', data.choices[0].message.content);
                        throw new Error('Failed to parse OpenAI response. The AI may not have returned valid JSON.');
                    }
                    
                    // Add classifications to conversations
                    batch.forEach((conv, index) => {
                        if (classifications[index] && classifications[index].category) {
                            conv.aiCategory = classifications[index].category;
                            conv.aiExplanation = classifications[index].explanation || '';
                        } else {
                            console.warn(`Missing classification for conversation ${index}:`, classifications[index]);
                            conv.aiCategory = 'not-relevant';
                            conv.aiExplanation = 'Failed to classify';
                        }
                    });

                    // Update display after each batch
                    displayConversations(conversations);
                }
            } catch (error) {
                console.error('Error analyzing with AI:', error);
                alert('Error analyzing conversations. Check console for details.');
            } finally {
                button.disabled = false;
                button.textContent = 'Analyze Titles with AI';
            }
        }

        function filterConversations() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const category = document.getElementById('categoryFilter').value;
            
            const filteredConvos = conversations.filter(convo => {
                const matchesSearch = (convo.title || '').toLowerCase().includes(searchTerm);
                const matchesCategory = category === 'all' || (convo.aiCategory && convo.aiCategory === category);
                return matchesSearch && matchesCategory;
            });
            
            displayConversations(filteredConvos);
        }

        // Update display function to show AI classifications
        function displayConversations(convos) {
            const container = document.getElementById('conversationList');
            container.innerHTML = convos.map((convo, index) => `
                <div class="conversation-item">
                    <div class="conversation-header" onclick="toggleSelection(${index})">
                        <input type="checkbox" id="convo-${index}">
                        <label for="convo-${index}" style="margin-left: 10px; flex-grow: 1;">
                            ${escapeHtml(convo.title || 'Untitled Conversation')}
                            ${convo.aiCategory ? 
                                `<span style="margin-left: 10px; padding: 2px 6px; border-radius: 3px; background-color: ${
                                    convo.aiCategory === 'relevant' ? '#c8e6c9' : '#ffcdd2'
                                };">${convo.aiCategory === 'relevant' ? 'Relevant' : 'Not Relevant'}</span>` 
                                : ''}
                            ${convo.aiExplanation ? 
                                `<br><small style="color: #666;">${escapeHtml(convo.aiExplanation)}</small>` 
                                : ''}
                        </label>
                        <button onclick="togglePreview(${index})" class="preview-btn">👁️ Preview</button>
                    </div>
                    <div id="preview-${index}" class="conversation-preview" style="display: none;">
                        <div class="preview-messages"></div>
                    </div>
                </div>
            `).join('');
        }

        // Update search to use new filter function
        document.getElementById('searchInput').addEventListener('input', filterConversations);

        // Load conversations and API key when the page loads
        loadConversations();
        loadApiKey();
    </script>
</body>
</html>